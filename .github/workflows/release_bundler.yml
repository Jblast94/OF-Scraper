# .github/workflows/package-builder-release.yml

name: Package Builder Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'The exact git tag to build (e.g., v8.4.1 or v8.4.1-alpha.1). Leave empty to auto-derive from latest Git tag.'
        required: true
      files:
        description: 'Build binary files? (t/f)'
        required: true
        type: boolean
      pip:
        description: 'Publish to PyPI? (t/f)'
        required: true
        type: boolean
      docker:
        description: 'Publish to Docker Hub & GHCR (t/f)'
        required: true
        type: boolean

permissions:
  contents: write # Needed for checkout, creating releases
  packages: write # Needed for pushing to GHCR/Docker Hub
  id-token: write # For OIDC, used by cosign, and CRUCIAL for GHCR authentication
  actions: write # Needed for gh CLI to upload/download workflow artifacts (for retries)

jobs:
  determine_tags_and_versions:
    name: Determine Release Info and Tagging Logic
    runs-on: ubuntu-latest
    outputs:
      long_hash: ${{ steps.release_info.outputs.long_hash }}
      short_hash: ${{ steps.release_info.outputs.short_hash }}
      package_version: ${{ steps.release_info.outputs.package_version }}
      is_stable_release: ${{ steps.release_info.outputs.is_stable_release }}
      is_dev_release: ${{ steps.release_info.outputs.is_dev_release }}
      should_apply_stable_latest: ${{ steps.release_info.outputs.should_apply_stable_latest }}
      should_apply_dev_latest: ${{ steps.release_info.outputs.should_apply_dev_latest }}
      commit_timestamp: ${{ steps.release_info.outputs.commit_timestamp }}
    steps:
      - name: Checkout Code (Optional Version or Current Branch)
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.version || github.ref }} # Checkout the specified tag/ref or default branch
          fetch-depth: 0 # Needed for git log and tag comparisons
          fetch-tags: true

      - name: Make release_version.sh executable
        run: chmod +x ./scripts/release_version.sh

      ## Docker Registry Inspection Setup (Pre-script)
      # These logins are specifically for this job to query registry APIs, not for building/pushing.
      # They must happen BEFORE the script runs if the script is to inspect registry tags.
      - name: Set up Docker Buildx (for manifest inspection)
        if: ${{ inputs.docker }}
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub (for manifest inspection)
        if: ${{ inputs.docker }}
        uses: docker/login-action@v3
        with:
          registry: docker.io
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Login to GHCR (for manifest inspection)
        if: ${{ inputs.docker }}
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }} # This implicitly uses OIDC due to id-token: write

      - name: Install Skopeo and JQ
        if: ${{ inputs.docker }}
        run: sudo apt-get update && sudo apt-get install -y skopeo jq

      - name: Get Release Info and Tagging Logic from Script
        id: release_info
        env:
          INPUT_VERSION: ${{ inputs.version }} # Pass input version (now guaranteed to be non-empty)
          # Pass the GitHub repository name to the script so it can use it for GHCR registry lookups
          GITHUB_REPOSITORY_SLUG: ${{ github.repository }}
        run: ./scripts/release_version.sh
        # The script now handles all output to GITHUB_OUTPUT

  build_binaries:
    if: ${{ inputs.files }}
    name: Build on ${{ matrix.os }}
    needs: [determine_tags_and_versions]
    runs-on: ${{ matrix.os }}

    defaults:
      run:
        shell: ${{ matrix.shell }}

    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        include:
          - os: ubuntu-latest
            artifact_suffix: linux
            shell: bash
          - os: windows-latest
            artifact_suffix: windows
            shell: pwsh
          - os: macos-latest
            artifact_suffix: macos
            shell: bash

    steps:
      - name: Checkout Full Git History
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.version || github.ref }} # Ensure correct ref for local build environment
          fetch-depth: 0 # Needed for git log and tag comparisons
          fetch-tags: true

      - name: Set up Python # This installs Python onto the runner
        uses: actions/setup-python@v5
        with:
          python-version: '3.12.0'

      - name: Install uv
        uses: astral-sh/setup-uv@v4

      - name: Prepare Version for Build Tools
        id: prep_build_version
        run: |
          PACKAGE_VERSION="${{ needs.determine_tags_and_versions.outputs.package_version }}"
          # Create a sanitized version for filenames by replacing '.' with '_'
          SANITIZED_TAG="${PACKAGE_VERSION//./_}"
          echo "SETUPTOOLS_SCM_PRETEND_VERSION=$PACKAGE_VERSION" >> "$GITHUB_ENV"
          echo "HATCH_VCS_PRETEND_VERSION=$PACKAGE_VERSION" >> "$GITHUB_ENV"
          echo "sanitized_tag=$SANITIZED_TAG" >> "$GITHUB_OUTPUT" # Output sanitized tag for artifact names
        shell: bash

      - name: Install venv and dependencies
        run: |
          uv venv

          if [ "${{ runner.os }}" == "Windows" ]; then
            . .venv/Scripts/activate
          else
            source .venv/bin/activate
          fi

          uv pip install --upgrade hatch-vcs setuptools-scm

          echo "Hatch version: $(hatch version)"

          uv sync --verbose
        shell: bash

      - name: Install PyInstaller
        run: uv pip install pyinstaller==6.14.1

      - name: Set UTF-8 environment (Windows)
        if: runner.os == 'Windows'
        run: |
          echo "PYTHONUTF8=1" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "PYTHONLEGACYWINDOWSSTDIO=utf8" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        shell: pwsh

      - name: Build Executable (File)
        run: |
          OFSCRAPER_EXECUTABLE="ofscraper/__main__.py"

          if [ "${{ runner.os }}" == "Windows" ]; then
              VENV_ACTIVATE=".venv/Scripts/activate"
              PYINSTALLER_OPTS="--python-option=utf8"
              EXE_EXT=".exe"
          else
              VENV_ACTIVATE=".venv/bin/activate"
              PYINSTALLER_OPTS="--clean --log DEBUG"
              EXE_EXT=""
          fi
          source "$VENV_ACTIVATE"
          echo "Building executable from: $OFSCRAPER_EXECUTABLE"
          pyinstaller --onefile \
            --name "ofscraper_${{ matrix.artifact_suffix }}_${{ steps.prep_build_version.outputs.sanitized_tag }}${EXE_EXT}" \
            ${PYINSTALLER_OPTS} \
            "$OFSCRAPER_EXECUTABLE"
        shell: bash

      - name: Build Executable (Dir)
        run: |
          OFSCRAPER_EXECUTABLE="ofscraper/__main__.py"

          if [ "${{ runner.os }}" == "Windows" ]; then
              VENV_ACTIVATE=".venv/Scripts/activate"
              PYINSTALLER_OPTS="--python-option=utf8"
          else
              VENV_ACTIVATE=".venv/bin/activate"
              PYINSTALLER_OPTS="--clean --log DEBUG"
          fi
          source "$VENV_ACTIVATE"
          echo "Building executable from: $OFSCRAPER_EXECUTABLE"
          pyinstaller \
            --name "ofscraper_${{ matrix.artifact_suffix }}_dir" \
            ${PYINSTALLER_OPTS} \
            "$OFSCRAPER_EXECUTABLE"
        shell: bash

      - name: Zip Directory (Unix)
        if: runner.os != 'Windows'
        run: zip -r "dist/ofscraper_${{ matrix.artifact_suffix }}_${{ steps.prep_build_version.outputs.sanitized_tag }}.zip" "dist/ofscraper_${{ matrix.artifact_suffix }}_dir"
        shell: bash

      - name: Zip Directory (Windows)
        if: runner.os == 'Windows'
        run: Compress-Archive -Path dist/ofscraper_${{ matrix.artifact_suffix }}_dir -DestinationPath dist/ofscraper_${{ matrix.artifact_suffix }}_${{ steps.prep_build_version.outputs.sanitized_tag }}.zip -Force
        shell: pwsh

      - name: Upload Build Artifacts (with retries)
        uses: Wandalen/wretry.action@master # Using Wandalen's retry action
        with:
          action: | # Embed the actual action to retry here
            - uses: actions/upload-artifact@v4
              with:
                name: build-artifacts-${{ matrix.os }}
                path: |
                  dist/ofscraper_${{ matrix.artifact_suffix }}_${{ steps.prep_build_version.outputs.sanitized_tag }}
                  dist/ofscraper_${{ matrix.artifact_suffix }}_${{ steps.prep_build_version.outputs.sanitized_tag }}.exe
                  dist/ofscraper_${{ matrix.artifact_suffix }}_${{ steps.prep_build_version.outputs.sanitized_tag }}.zip
                if-no-files-found: ignore # This option is directly supported by actions/upload-artifact
          attempts: 3 # Number of retry attempts
          timeout_minutes: 5 # Timeout for each attempt of the inner action

  publish_release:
    name: Publish GitHub Release
    if: ${{ inputs.files }}
    needs: [build_binaries, determine_tags_and_versions]
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read # Needed for gh CLI to download artifacts for this job
    steps:
      - name: Download all build artifacts (with retries)
        uses: Wandalen/wretry.action@master # Using Wandalen's retry action
        with:
          action: | # Embed the actual action to retry here
            - uses: actions/download-artifact@v4
              with:
                path: artifacts/
          attempts: 3 # Number of retry attempts
          timeout_minutes: 5 # Timeout for each attempt of the inner action

      - name: List downloaded files for debugging
        run: ls -R artifacts

      - name: Create or Update Release
        # ncipollo/release-action is generally robust. For its specific network interactions,
        # it likely has internal retries. If persistent errors occur, check API rate limits or permissions.
        uses: ncipollo/release-action@v1
        with:
          artifacts: artifacts/*/*
          tag: ${{ inputs.version }}
          name: "Release ${{ inputs.version }}"
          body: "Release build for version ${{ inputs.version }}, created from commit hash `${{ needs.determine_tags_and_versions.outputs.long_hash }}`."
          allowUpdates: true

  pypi:
    needs: [determine_tags_and_versions]
    if: ${{ inputs.pip }}
    runs-on: ubuntu-latest
    name: create pypi
    permissions:
      id-token: write # Needed for OIDC authentication to PyPI (if using trusted publisher)
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          ref: ${{ inputs.version || github.ref }}
      - run: git checkout ${{ needs.determine_tags_and_versions.outputs.long_hash }}
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: 3.11.5
      - name: Install uv
        uses: astral-sh/setup-uv@v4
      - name: Install Build and Publish Tools
        run: uv pip install hatch twine
      - name: Build Package with Hatch
        run: |
          PACKAGE_VERSION="${{ needs.determine_tags_and_versions.outputs.package_version }}"
          echo "Setting package version to $PACKAGE_VERSION for the build."
          export HATCH_VCS_PRETEND_VERSION=$PACKAGE_VERSION
          hatch build
        shell: bash

      - name: Publish to PyPI with Twine
        # Removed bash retry loop as per user request for performance
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.pypi }}
        run: twine upload "dist/*"
        shell: bash # Ensure shell is bash for the command

  # New job for Docker Hub publishing
  publish_docker_hub:
    needs: [determine_tags_and_versions]
    if: ${{ inputs.docker }}
    runs-on: ubuntu-latest
    name: Publish to Docker Hub
    permissions:
      contents: read
      packages: write
      id-token: write # Required for Cosign signing (if enabled)
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.version || github.ref }}
      - run: git checkout ${{ needs.determine_tags_and_versions.outputs.long_hash }}

      - name: Set up Docker buildx
        uses: docker/setup-buildx-action@v3
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      - name: Install cosign
        uses: sigstore/cosign-installer@v3.5.0

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract Docker metadata for Docker Hub
        id: meta_hub
        uses: docker/metadata-action@v5
        with:
          images: datawhores/of-scraper
          tags: |
            type=raw,value=${{ inputs.version }}
            type=raw,value=${{ needs.determine_tags_and_versions.outputs.package_version }}
            type=raw,value=latest,enable=${{ needs.determine_tags_and_versions.outputs.is_stable_release && needs.determine_tags_and_versions.outputs.should_apply_stable_latest }}
            type=raw,value=dev,enable=${{ needs.determine_tags_and_versions.outputs.is_dev_release && needs.determine_tags_and_versions.outputs.should_apply_dev_latest }}
            type=raw,value=stable,enable=${{ needs.determine_tags_and_versions.outputs.is_stable_release }}
      - name: Build and Push Docker Hub Image
        id: build-and-push-hub
        # docker/build-push-action has internal retry mechanisms for transient network issues.
        # A 403 error often indicates a permissions misconfiguration, which retries won't fix.
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          build-args: |
            SETUPTOOLS_SCM_PRETEND_VERSION=${{ needs.determine_tags_and_versions.outputs.package_version }}
            HATCH_VCS_PRETEND_VERSION=${{ needs.determine_tags_and_versions.outputs.package_version }}
          tags: ${{ steps.meta_hub.outputs.tags }}
          labels: ${{ steps.meta_hub.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          push: true
          outputs: |
            type=image,annotation=org.opencontainers.image.revision=${{ needs.determine_tags_and_versions.outputs.long_hash }}

      - name: Write Docker Hub signing key to disk
        if: ${{ inputs.docker }}
        run: echo "${{ secrets.COSIGN_PRIVATE_KEY }}" > cosign.key
        shell: bash
        env:
          KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}

      - name: Sign the published Docker Hub image
        # Removed bash retry loop as per user request for performance
        if: ${{ inputs.docker }}
        env:
          COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
          COSIGN_EXPERIMENTAL: "true"
        run: |
          echo "Signing Docker Hub image..."
          # Sign the exact set of desired tags
          docker_hub_signed_tags=""
          if [ -n "${{ inputs.version }}" ]; then
            docker_hub_signed_tags+=" datawhores/of-scraper:${{ inputs.version }}"
          fi
          docker_hub_signed_tags+=" datawhores/of-scraper:${{ needs.determine_tags_and_versions.outputs.package_version }}"

          if ${{ needs.determine_tags_and_versions.outputs.is_stable_release }}; then
            docker_hub_signed_tags+=" datawhores/of-scraper:stable"
          fi
          if ${{ needs.determine_tags_and_versions.outputs.is_stable_release && needs.determine_tags_and_versions.outputs.should_apply_stable_latest }}; then
            docker_hub_signed_tags+=" datawhores/of-scraper:latest"
          fi
          if ${{ needs.determine_tags_and_versions.outputs.is_dev_release && needs.determine_tags_and_versions.outputs.should_apply_dev_latest }}; then
            docker_hub_signed_tags+=" datawhores/of-scraper:dev"
          fi
          echo "$docker_hub_signed_tags" | xargs -n 1 -I {} cosign sign --yes --key cosign.key {}@${{ steps.build-and-push-hub.outputs.digest }}
        shell: bash

  # New job for GHCR publishing
  publish_ghcr:
    needs: [determine_tags_and_versions]
    if: ${{ inputs.docker }}
    runs-on: ubuntu-latest
    name: Publish to GHCR
    permissions:
      contents: read
      packages: write
      id-token: write # CRUCIAL for GHCR authentication and signing
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.version || github.ref }}
      - run: git checkout ${{ needs.determine_tags_and_versions.outputs.long_hash }}

      - name: Set up Docker buildx
        uses: docker/setup-buildx-action@v3
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      - name: Install cosign
        uses: sigstore/cosign-installer@v3.5.0

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }} # Authenticates with GHCR via OIDC due to id-token: write

      - name: Extract Docker metadata for GHCR
        id: meta_ghcr
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=raw,value=${{ inputs.version }}
            type=raw,value=${{ needs.determine_tags_and_versions.outputs.package_version }}
            type=raw,value=latest,enable=${{ needs.determine_tags_and_versions.outputs.is_stable_release && needs.determine_tags_and_versions.outputs.should_apply_stable_latest }}
            type=raw,value=dev,enable=${{ needs.determine_tags_and_versions.outputs.is_dev_release && needs.determine_tags_and_versions.outputs.should_apply_dev_latest }}
            type=raw,value=stable,enable=${{ needs.determine_tags_and_versions.outputs.is_stable_release }}
      - name: Build and Push GHCR Image
        id: build-and-push-ghcr
        # docker/build-push-action has internal retry mechanisms for transient network issues.
        # A 403 error often indicates a permissions misconfiguration, which retries won't fix.
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          build-args: |
            SETUPTOOLS_SCM_PRETEND_VERSION=${{ needs.determine_tags_and_versions.outputs.package_version }}
            HATCH_VCS_PRETEND_VERSION=${{ needs.determine_tags_and_versions.outputs.package_version }}
          tags: ${{ steps.meta_ghcr.outputs.tags }}
          labels: ${{ steps.meta_ghcr.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          push: true
          outputs: |
            type=image,annotation=org.opencontainers.image.revision=${{ needs.determine_tags_and_versions.outputs.long_hash }}

      - name: Sign the published GHCR image (via OIDC/Keyless)
        # Removed bash retry loop as per user request for performance
        if: ${{ inputs.docker }}
        env:
          COSIGN_EXPERIMENTAL: "true"
          # COSIGN_FULCIO_ENABLED: "true" # Might be needed depending on Cosign version/setup for Fulcio
        run: |
          echo "Signing GHCR image..."
          # Sign the exact set of desired tags
          ghcr_signed_tags=""
          if [ -n "${{ inputs.version }}" ]; then
            ghcr_signed_tags+=" ghcr.io/${{ github.repository }}:${{ inputs.version }}"
          fi
          ghcr_signed_tags+=" ghcr.io/${{ github.repository }}:${{ needs.determine_tags_and_versions.outputs.package_version }}"

          if ${{ needs.determine_tags_and_versions.outputs.is_stable_release }}; then
            ghcr_signed_tags+=" ghcr.io/${{ github.repository }}:stable"
          fi
          if ${{ needs.determine_tags_and_versions.outputs.is_stable_release && needs.determine_tags_and_versions.outputs.should_apply_stable_latest }}; then
            ghcr_signed_tags+=" ghcr.io/${{ github.repository }}:latest"
          fi
          if ${{ needs.determine_tags_and_versions.outputs.is_dev_release && needs.determine_tags_and_versions.outputs.should_apply_dev_latest }}; then
            ghcr_signed_tags+=" ghcr.io/${{ github.repository }}:dev"
          fi
          echo "$ghcr_signed_tags" | xargs -n 1 -I {} cosign sign --yes {}@${{ steps.build-and-push-ghcr.outputs.digest }}
        shell: bash