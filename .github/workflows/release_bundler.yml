# .github/workflows/package-builder-release.yml

name: Package Builder Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'The exact git tag to build (e.g., v8.4.1 or v8.4.1-alpha.1). Leave empty to auto-derive from latest Git tag.'
        required: true # Changed to optional
      files:
        description: 'Build binary files? (t/f)'
        required: false
        type: boolean
      pip:
        description: 'Publish to PyPI? (t/f)'
        required: false
        type: boolean
      docker:
        description: 'Publish to Docker Hub & GHCR (including latest/dev tags)? (t/f)'
        required: false
        type: boolean

permissions:
  contents: read
  packages: write
  id-token: write # For OIDC, used by cosign, and CRUCIAL for GHCR authentication

jobs:
  determine_tags_and_versions:
    name: Determine Release Info and Tagging Logic
    runs-on: ubuntu-latest
    outputs:
      long_hash: ${{ steps.release_info.outputs.long_hash }}
      package_version: ${{ steps.release_info.outputs.package_version }}
      is_stable_release: ${{ steps.release_info.outputs.is_stable_release }}
      is_dev_release: ${{ steps.release_info.outputs.is_dev_release }}
      should_apply_stable_latest: ${{ steps.release_info.outputs.should_apply_stable_latest }}
      should_apply_dev_latest: ${{ steps.release_info.outputs.should_apply_dev_latest }}
    steps:
      - name: Checkout Code (Optional Version or Current Branch)
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.version || github.ref }} # Checkout the specified tag/ref or default branch
          fetch-depth: 0 # Needed for git log and tag comparisons
          fetch-tags: true

      - name: Make release_version.sh executable
        run: chmod +x ./scripts/release_version.sh
      - name: Set up Docker Buildx (for manifest inspection)
        if: ${{ inputs.docker }}
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub (for manifest inspection)
        if: ${{ inputs.docker }}
        uses: docker/login-action@v3
        with:
          registry: docker.io
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Login to GHCR (for manifest inspection)
        if: ${{ inputs.docker }}
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }} # This implicitly uses OIDC due to id-token: write

      - name: Install Skopeo and JQ
        if: ${{ inputs.docker }}
        run: sudo apt-get update && sudo apt-get install -y skopeo jq

      - name: Get Release Info and Tagging Logic from Script
        id: release_info
        env:
          INPUT_VERSION: ${{ inputs.version }} # Pass input version (might be empty) to script
          # Pass the GitHub repository name to the script so it can use it for GHCR registry lookups
          GITHUB_REPOSITORY_SLUG: ${{ github.repository }} # This is `owner/repo-name`
        run: ./scripts/release_version.sh
        # The script now handles all output to GITHUB_OUTPUT

  build_binaries:
    if: ${{ inputs.files }}
    name: Build on ${{ matrix.os }}
    needs: [determine_tags_and_versions]
    runs-on: ${{ matrix.os }}

    defaults:
      run:
        shell: ${{ matrix.shell }}

    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        include:
          - os: ubuntu-latest
            artifact_suffix: linux
            shell: bash
          - os: windows-latest
            artifact_suffix: windows
            shell: pwsh
          - os: macos-latest
            artifact_suffix: macos
            shell: bash

    steps:
      - name: Checkout Full Git History
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          ref: ${{ inputs.version || github.ref }} # Ensure correct ref for local build environment
      - name: Set up Python # This installs Python onto the runner
        uses: actions/setup-python@v5
        with:
          python-version: '3.12.0'

      - name: Install uv
        uses: astral-sh/setup-uv@v4

      - name: Prepare Version for Build Tools
        id: prep_build_version
        run: |
          PACKAGE_VERSION="${{ needs.determine_tags_and_versions.outputs.package_version }}"
          # Create a sanitized version for filenames by replacing '.' with '_'
          SANITIZED_TAG="${PACKAGE_VERSION//./_}"
          echo "SETUPTOOLS_SCM_PRETEND_VERSION=$PACKAGE_VERSION" >> "$GITHUB_ENV"
          echo "HATCH_VCS_PRETEND_VERSION=$PACKAGE_VERSION" >> "$GITHUB_ENV"
          echo "sanitized_tag=$SANITIZED_TAG" >> "$GITHUB_OUTPUT" # Output sanitized tag for artifact names
        shell: bash

      - name: Install venv and dependencies
        run: |
          uv venv

          if [ "${{ runner.os }}" == "Windows" ]; then
            . .venv/Scripts/activate
          else
            source .venv/bin/activate
          fi

          uv pip install --upgrade hatch-vcs setuptools-scm

          echo "Hatch version: $(hatch version)"

          uv sync --verbose
        shell: bash

      - name: Install PyInstaller
        run: uv pip install pyinstaller==6.14.1

      - name: Set UTF-8 environment (Windows)
        if: runner.os == 'Windows'
        run: |
          echo "PYTHONUTF8=1" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "PYTHONLEGACYWINDOWSSTDIO=utf8" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        shell: pwsh

      - name: Build Executable (File)
        run: |
          OFSCRAPER_EXECUTABLE="ofscraper/__main__.py"

          if [ "${{ runner.os }}" == "Windows" ]; then
              VENV_ACTIVATE=".venv/Scripts/activate"
              PYINSTALLER_OPTS="--python-option=utf8"
              EXE_EXT=".exe"
          else
              VENV_ACTIVATE=".venv/bin/activate"
              PYINSTALLER_OPTS="--clean --log DEBUG"
              EXE_EXT=""
          fi
          source "$VENV_ACTIVATE"
          echo "Building executable from: $OFSCRAPER_EXECUTABLE"
          pyinstaller --onefile \
            --name "ofscraper_${{ matrix.artifact_suffix }}_${{ steps.prep_build_version.outputs.sanitized_tag }}${EXE_EXT}" \
            ${PYINSTALLER_OPTS} \
            "$OFSCRAPER_EXECUTABLE"
        shell: bash

      - name: Build Executable (Dir)
        run: |
          OFSCRAPER_EXECUTABLE="ofscraper/__main__.py"

          if [ "${{ runner.os }}" == "Windows" ]; then
              VENV_ACTIVATE=".venv/Scripts/activate"
              PYINSTALLER_OPTS="--python-option=utf8"
          else
              VENV_ACTIVATE=".venv/bin/activate"
              PYINSTALLER_OPTS="--clean --log DEBUG"
          fi
          source "$VENV_ACTIVATE"
          echo "Building executable from: $OFSCRAPER_EXECUTABLE"
          pyinstaller \
            --name "ofscraper_${{ matrix.artifact_suffix }}_dir" \
            ${PYINSTALLER_OPTS} \
            "$OFSCRAPER_EXECUTABLE"
        shell: bash

      - name: Zip Directory (Unix)
        if: runner.os != 'Windows'
        run: zip -r "dist/ofscraper_${{ matrix.artifact_suffix }}_${{ steps.prep_build_version.outputs.sanitized_tag }}.zip" "dist/ofscraper_${{ matrix.artifact_suffix }}_dir"
        shell: bash

      - name: Zip Directory (Windows)
        if: runner.os == 'Windows'
        run: Compress-Archive -Path dist/ofscraper_${{ matrix.artifact_suffix }}_dir -DestinationPath dist/ofscraper_${{ matrix.artifact_suffix }}_${{ steps.prep_build_version.outputs.sanitized_tag }}.zip -Force
        shell: pwsh

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ matrix.os }}
          path: |
            dist/ofscraper_${{ matrix.artifact_suffix }}_${{ steps.prep_build_version.outputs.sanitized_tag }}
            dist/ofscraper_${{ matrix.artifact_suffix }}_${{ steps.prep_build_version.outputs.sanitized_tag }}.exe
            dist/ofscraper_${{ matrix.artifact_suffix }}_${{ steps.prep_build_version.outputs.sanitized_tag }}.zip
          if-no-files-found: ignore

  publish_release:
    name: Publish GitHub Release
    if: ${{ inputs.files }}
    needs: [build_binaries, determine_tags_and_versions]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/

      - name: List downloaded files for debugging
        run: ls -R artifacts

      - name: Create or Update Release
        uses: ncipollo/release-action@v1
        with:
          artifacts: artifacts/*/*
          tag: ${{ inputs.version }}
          name: "Release ${{ inputs.version }}"
          body: "Release build for version ${{ inputs.version }}, created from commit hash `${{ needs.determine_tags_and_versions.outputs.long_hash }}`."
          allowUpdates: true

  pypi:
    needs: [determine_tags_and_versions]
    if: ${{ inputs.pip }}
    runs-on: ubuntu-latest
    name: create pypi
    permissions:
      id-token: write # Needed for OIDC authentication to PyPI (if using trusted publisher)
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          ref: ${{ inputs.version || github.ref }}
      - run: git checkout ${{ needs.determine_tags_and_versions.outputs.long_hash }}
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: 3.11.5
      - name: Install uv
        uses: astral-sh/setup-uv@v4
      - name: Install Build and Publish Tools
        run: uv pip install hatch twine
      - name: Build Package with Hatch
        run: |
          PACKAGE_VERSION="${{ needs.determine_tags_and_versions.outputs.package_version }}"
          echo "Setting package version to $PACKAGE_VERSION for the build."
          export HATCH_VCS_PRETEND_VERSION=$PACKAGE_VERSION
          hatch build
        shell: bash

      - name: Publish to PyPI with Twine
        env:
          TWINE_USERNAME: __token__
          # If using PyPI trusted publisher, TWINE_PASSWORD is not needed.
          # Otherwise, ensure this secret is configured.
          TWINE_PASSWORD: ${{ secrets.pypi }}
        run: twine upload "dist/*"

  docker: # Docker Hub & GHCR combined
    needs: [determine_tags_and_versions]
    if: ${{ inputs.docker }}
    runs-on: ubuntu-latest
    name: Docker Hub & GHCR Release
    permissions:
      contents: read
      packages: write
      id-token: write # CRUCIAL for GHCR authentication
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.version || github.ref }}
      - run: git checkout ${{ needs.determine_tags_and_versions.outputs.long_hash }}

      - name: Set up Docker buildx
        uses: docker/setup-buildx-action@v3
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      - name: Install cosign
        uses: sigstore/cosign-installer@v3.5.0 # Latest stable cosign installer

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }} # Authenticates with GHCR via OIDC due to id-token: write

      - name: Build and Push Docker Images
        id: build-and-push
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64 # Multi-arch build
          build-args: |
            SETUPTOOLS_SCM_PRETEND_VERSION=${{ needs.determine_tags_and_versions.outputs.package_version }}
            HATCH_VCS_PRETEND_VERSION=${{ needs.determine_tags_and_versions.outputs.package_version }}
          tags: |
            datawhores/of-scraper:${{ inputs.version }}
            datawhores/of-scraper:${{ needs.determine_tags_and_versions.outputs.package_version }}
            ghcr.io/datawhores/of-scraper:${{ inputs.version }}
            ghcr.io/datawhores/of-scraper:${{ needs.determine_tags_and_versions.outputs.package_version }}
            type=raw,value=latest,enable=${{ needs.determine_tags_and_versions.outputs.is_stable_release && needs.determine_tags_and_versions.outputs.should_apply_stable_latest }}
            type=raw,value=dev,enable=${{ needs.determine_tags_and_versions.outputs.is_dev_release && needs.determine_tags_and_versions.outputs.should_apply_dev_latest }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          push: true
          # Capture output of the digest for signing
          outputs: |
            type=image,annotation=org.opencontainers.image.revision=${{ needs.determine_tags_and_versions.outputs.long_hash }}

      - name: Write Docker Hub signing key to disk
        # Only if Docker Hub image is pushed and signing is enabled
        if: ${{ inputs.docker }}
        run: echo "${{ secrets.COSIGN_PRIVATE_KEY }}" > cosign.key
        shell: bash
        env:
          KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}

      - name: Sign the published Docker Hub image
        # Only if Docker Hub image is pushed and signing is enabled
        if: ${{ inputs.docker }}
        env:
          COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
          COSIGN_EXPERIMENTAL: "true"
        run: |
          echo "Signing Docker Hub image..."
          # Sign both the versioned tag and dynamically applied tags for Docker Hub
          docker_hub_tags="datawhores/of-scraper:${{ needs.determine_tags_and_versions.outputs.package_version }}"
          if ${{ needs.determine_tags_and_versions.outputs.is_stable_release && needs.determine_tags_and_versions.outputs.should_apply_stable_latest }}; then
            docker_hub_tags="${docker_hub_tags} datawhores/of-scraper:latest"
          fi
          if ${{ needs.determine_tags_and_versions.outputs.is_dev_release && needs.determine_tags_and_versions.outputs.should_apply_dev_latest }}; then
            docker_hub_tags="${docker_hub_tags} datawhores/of-scraper:dev"
          fi
          echo "$docker_hub_tags" | xargs -n 1 -I {} cosign sign --yes --key cosign.key {}@${{ steps.build-and-push.outputs.digest }}

      - name: Sign the published GHCR image (via OIDC/Keyless)
        # This step is enabled and will attempt keyless signing for GHCR images.
        # This relies on the 'id-token: write' permission and Sigstore's public services (Fulcio/Rekor).
        # No private key or password secrets are needed for this signing method.
        if: ${{ inputs.docker }} # Only attempt if docker publishing is enabled
        env:
          COSIGN_EXPERIMENTAL: "true"
          # COSIGN_FULCIO_ENABLED: "true" # Might be needed depending on Cosign version/setup for Fulcio
        run: |
          echo "Signing GHCR image via OIDC/Keyless signing..."
          # Sign both the versioned tag and dynamically applied tags for GHCR
          ghcr_tags="ghcr.io/datawhores/of-scraper:${{ needs.determine_tags_and_versions.outputs.package_version }}"
          if ${{ needs.determine_tags_and_versions.outputs.is_stable_release && needs.determine_tags_and_versions.outputs.should_apply_stable_latest }}; then
            ghcr_tags="${ghcr_tags} ghcr.io/datawhores/of-scraper:latest"
          fi
          if ${{ needs.determine_tags_and_versions.outputs.is_dev_release && needs.determine_tags_and_versions.outputs.should_apply_dev_latest }}; then
            ghcr_tags="${ghcr_tags} ghcr.io/datawhores/of-scraper:dev"
          fi
          # For OIDC-based signing, you typically don't pass '--key' or '--password'.
          # Cosign uses the OIDC token available in the environment implicitly.
          echo "$ghcr_tags" | xargs -n 1 -I {} cosign sign --yes {}@${{ steps.build-and-push.outputs.digest }}