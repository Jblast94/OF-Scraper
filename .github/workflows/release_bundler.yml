name: package builder release
permissions: read-all
on:
  workflow_dispatch:
    inputs:
      version:
        description: version
        required: true
      files:
        required: true
        type: boolean
      pip:
        required: true
        type: boolean
      docker:
        required: true
        type: boolean
      docker_old:
        required: true
        type: boolean
jobs:
  build_binaries:
    name: Build on ${{ matrix.os }}
    needs: [get_commit]
    runs-on: ${{ matrix.os }}

    defaults:
      run:
        shell: ${{ matrix.shell }}

    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
   


        include:
          - os: ubuntu-latest
            artifact_suffix: linux
            shell: bash
          - os: windows-latest
            artifact_suffix: windows
            shell: pwsh
          - os: macos-latest
            artifact_suffix: macos
            shell: bash

    steps:
      - name: Checkout Full Git History
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Get all history
          fetch-tags: true  # Get all tags
          ref: ${{inputs.version}}
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12.0'

      - name: Install uv
        uses: astral-sh/setup-uv@v4
  
      - name: Get latest compatible version tag
        id: get_version
        run: |
          # Get all tags matching your pattern
          ALL_TAGS=$(git tag --list)
          echo "All tags: $ALL_TAGS"
          
          # Filter tags by pattern and sort by version
          FILTERED_TAGS=$(echo "$ALL_TAGS" | grep -E '^v?[0-9]+\.[0-9]+(\.[0-9]+)?(\.[a-zA-Z0-9]+)?$' | sort -V -r)
          echo "Filtered tags: $FILTERED_TAGS"
          
          # Select the highest version tag
          SELECTED_TAG=$(echo "$FILTERED_TAGS" | head -n 1)
          
          # Fallback to 0.0.0 if no tags found
          if [ -z "$SELECTED_TAG" ]; then
            SELECTED_TAG="0.0.0"
          else
            # Remove 'v' prefix if present
            SELECTED_TAG=${SELECTED_TAG#v}
          fi
          
          echo "Using version: $SELECTED_TAG"
          echo "SETUPTOOLS_SCM_PRETEND_VERSION=$SELECTED_TAG" >> $GITHUB_ENV
          echo "HATCH_VCS_PRETEND_VERSION=$SELECTED_TAG" >> $GITHUB_ENV
        shell: bash

      - name: Install venv and dependencies
        run: |
          uv venv
          
          # Activate venv based on OS
          if [ "${{ runner.os }}" == "Windows" ]; then
            . .venv/Scripts/activate
          else
            source .venv/bin/activate
          fi
          
          # Install versioning dependencies
          uv pip install --upgrade hatch-vcs setuptools-scm
          
          # Verify version detection
          echo "Hatch version: $(hatch version)"
          
          # Run the sync
          uv sync --verbose
        shell: bash
      - name: Install PyInstaller
        run: uv pip install pyinstaller==6.14.1
      - name: Set UTF-8 environment (Windows)
        if: runner.os == 'Windows'
        run: |
          echo "PYTHONUTF8=1" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "PYTHONLEGACYWINDOWSSTDIO=utf8" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        shell: pwsh


      - name: Build Executable (File)
        run: |
          # Set common variables
          OFSCRAPER_EXECUTABLE="ofscraper/__main__.py"

          # OS-specific settings
          if [ "${{ runner.os }}" == "Windows" ]; then
              VENV_ACTIVATE=".venv/Scripts/activate"
              PYINSTALLER_OPTS="--python-option=utf8"
              EXE_EXT=".exe"
          else
              VENV_ACTIVATE=".venv/bin/activate"
              PYINSTALLER_OPTS="--clean --log DEBUG"
              EXE_EXT=""
          fi
          # Activate venv
          source $VENV_ACTIVATE
          # Build command
          echo "Building executable from: $OFSCRAPER_EXECUTABLE"
          pyinstaller --onefile \
            --name "ofscraper_${{ matrix.artifact_suffix }}_${{inputs.version}}$EXE_EXT" \
            $PYINSTALLER_OPTS \
            "$OFSCRAPER_EXECUTABLE"
        shell: bash

      - name: Build Executable (Dir)
        run: |
          # Set common variables
          OFSCRAPER_EXECUTABLE="ofscraper/__main__.py"

          # OS-specific settings
          if [ "${{ runner.os }}" == "Windows" ]; then
              VENV_ACTIVATE=".venv/Scripts/activate"
              PYINSTALLER_OPTS="--python-option=utf8"
          else
              VENV_ACTIVATE=".venv/bin/activate"
              PYINSTALLER_OPTS="--clean --log DEBUG"
          fi
          # Activate venv
          source $VENV_ACTIVATE
          # Build command
          echo "Building executable from: $OFSCRAPER_EXECUTABLE"
          pyinstaller\
            --name "ofscraper_${{ matrix.artifact_suffix }}_dir" \
            $PYINSTALLER_OPTS \
            "$OFSCRAPER_EXECUTABLE"
        shell: bash


      - name: Zip Directory (Unix)
        if: runner.os != 'Windows'
        run: zip -r "dist/ofscraper_${{ matrix.artifact_suffix }}_${{inputs.version}}.zip" "dist/ofscraper_${{ matrix.artifact_suffix }}_dir"
        shell: bash

      - name: Zip Directory (Windows)
        if: runner.os == 'Windows'
        run: Compress-Archive -Path dist/ofscraper_${{ matrix.artifact_suffix }}_dir -DestinationPath dist/ofscraper_${{ matrix.artifact_suffix }}_${{inputs.version}}.zip -Force
        shell: pwsh
        
      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ matrix.artifact_suffix }}
          path: |
            dist/ofscraper_${{ matrix.artifact_suffix }}_${{inputs.version}}
            dist/ofscraper_${{ matrix.artifact_suffix }}_${{inputs.version}}.exe
            dist/ofscraper_${{ matrix.artifact_suffix }}_${{inputs.version}}.zip
          if-no-files-found: ignore


  pypi:
    needs: [get_commit]
    if: ${{ inputs.pip}}
    runs-on: ubuntu-latest
    name: create pypi
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          ref: ${{inputs.version}}
      - run: git checkout ${{needs.get_commit.outputs.long}}
      - name: Set up Python 3.11.5
        uses: actions/setup-python@v4
        with:
          python-version: 3.11.5
      - name: üêç Install dependencies
        run: |
          pip install poetry-dynamic-versioning
          pip install dunamai
      - name: Install Poetry
        uses: snok/install-poetry@v1
      - name: Build
        run: |
          poetry version $(dunamai from git --format "{base}" --pattern="(?P<base>\d+\.\d+(\.((\d+\.\w+)|\w+)|))")
          poetry build
      - name: Push to pypi
        env:
          PYPI_TOKEN: ${{ secrets.pypi }}
        run: |
          poetry config pypi-token.pypi $PYPI_TOKEN
          poetry publish
  docker:
    needs: [get_commit]
    if: ${{ inputs.docker}}
    runs-on: ubuntu-latest
    name: DockerHub Release
    permissions:
      contents: read
      packages: write
      # This is used to complete the identity challenge
      # with sigstore/fulcio when running outside of PRs.
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{inputs.version}}
      - run: git checkout ${{needs.get_commit.outputs.long}}
      - name: get tag
        run: echo release=$(git describe --tags `git rev-list --tags --max-count=1`) >> $GITHUB_ENV
      - name: Setup Docker buildx
        uses: docker/setup-buildx-action@v2
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2
      #Install the cosign tool except on PR
      #https://github.com/sigstore/cosign-installer
      - name: Install cosign
        uses: sigstore/cosign-installer@main #v2.6.0
        with:
          cosign-release: v1.13.1
      #Login against a Docker registry except on PR
      #https://github.com/docker/login-action

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: push image to Docker Hub
        id: build-and-push
        uses: docker/build-push-action@v4
        with:
          context: .
          tags: |
            datawhores/of-scraper:${{ inputs.version }}
            datawhores/of-scraper:latest

          cache-from: type=gha
          cache-to: type=gha,mode=max
          push: true

      - name: cosign-installer
        uses: sigstore/cosign-installer@v3.0.5

      - name: Write signing key to disk
        run: echo "$KEY" > cosign.key
        shell: bash
        env:
          KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}

      - name: Sign the published Docker image
        env:
          COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
          COSIGN_EXPERIMENTAL: "true"
        run: echo "datawhores/of-scraper:${{ env.release }}" | xargs -I {} cosign sign --yes --key cosign.key {}@${{ steps.build-and-push.outputs.digest }}

      #       # Sign the resulting Docker image digest except on PRs.
      #       # This will only write to the public Rekor transparency log when the Docker
      #       # repository is public to avoid leaking data.  If you would like to publish
      #       # transparency data even for private images, pass --force to cosign below.
      #       # https://github.com/sigstore/cosign
      #       - name: Sign the published Docker image
      #         env:
      #           COSIGN_EXPERIMENTAL: "true"
      #         # This step uses the identity token to provision an ephemeral certificate
      #         # against the sigstore community Fulcio instance.
      #         run: echo "datawhores/of-scraper:${{ env.release }}" | xargs -I {} cosign sign {}@${{ steps.build-and-push.outputs.digest }}
      #Login against a Docker registry except on PR
      #https://github.com/docker/login-action
  github_docker:
    needs: [get_commit]
    if: ${{ inputs.docker}}
    runs-on: ubuntu-latest
    name: Docker GHCR Release
    permissions:
      contents: read
      packages: write
      # This is used to complete the identity challenge
      # with sigstore/fulcio when running outside of PRs.
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{inputs.version}}
      - run: git checkout ${{needs.get_commit.outputs.long}}
      - name: get tag
        run: echo release=$(git describe --tags `git rev-list --tags --max-count=1`) >> $GITHUB_ENV
      - name: Setup Docker buildx
        uses: docker/setup-buildx-action@v2
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2
      #Install the cosign tool except on PR
      #https://github.com/sigstore/cosign-installer
      - name: Install cosign
        uses: sigstore/cosign-installer@main #v2.6.0
        with:
          cosign-release: v1.13.1
      #Login against a Docker registry except on PR
      #https://github.com/docker/login-action

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: login to ghcr
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN}}
          # Extract metadata (tags, labels) for Docker
      - name: push image to ghcr
        id: build-and-push2
        uses: docker/build-push-action@v4
        with:
          context: .
          tags: |
            ghcr.io/datawhores/of-scraper:${{ inputs.version }}
            ghcr.io/datawhores/of-scraper:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          push: true

  docker_old:
    needs: [get_commit]
    if: ${{ inputs.docker_old}}
    runs-on: ubuntu-latest
    name: DockerHub Release Old
    permissions:
      contents: read
      packages: write
      # This is used to complete the identity challenge
      # with sigstore/fulcio when running outside of PRs.
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{inputs.version}}
      - run: git checkout ${{needs.get_commit.outputs.long}}
      - name: get tag
        run: echo release=$(git describe --tags `git rev-list --tags --max-count=1`) >> $GITHUB_ENV
      - name: Setup Docker buildx
        uses: docker/setup-buildx-action@v2
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2
      #Install the cosign tool except on PR
      #https://github.com/sigstore/cosign-installer
      - name: Install cosign
        uses: sigstore/cosign-installer@main #v2.6.0
        with:
          cosign-release: v1.13.1
      #Login against a Docker registry except on PR
      #https://github.com/docker/login-action

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: push image to Docker Hub
        id: build-and-push
        uses: docker/build-push-action@v4
        with:
          context: .
          tags: |
            datawhores/of-scraper:${{ inputs.version }}

          cache-from: type=gha
          cache-to: type=gha,mode=max
          push: true

      - name: cosign-installer
        uses: sigstore/cosign-installer@v3.0.5

      - name: Write signing key to disk
        run: echo "$KEY" > cosign.key
        shell: bash
        env:
          KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}

      - name: Sign the published Docker image
        env:
          COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
          COSIGN_EXPERIMENTAL: "true"
        run: echo "datawhores/of-scraper:${{ env.release }}" | xargs -I {} cosign sign --yes --key cosign.key {}@${{ steps.build-and-push.outputs.digest }}

      #       # Sign the resulting Docker image digest except on PRs.
      #       # This will only write to the public Rekor transparency log when the Docker
      #       # repository is public to avoid leaking data.  If you would like to publish
      #       # transparency data even for private images, pass --force to cosign below.
      #       # https://github.com/sigstore/cosign
      #       - name: Sign the published Docker image
      #         env:
      #           COSIGN_EXPERIMENTAL: "true"
      #         # This step uses the identity token to provision an ephemeral certificate
      #         # against the sigstore community Fulcio instance.
      #         run: echo "datawhores/of-scraper:${{ env.release }}" | xargs -I {} cosign sign {}@${{ steps.build-and-push.outputs.digest }}
      #Login against a Docker registry except on PR
      #https://github.com/docker/login-action

  docker_old_github:
    needs: [get_commit]
    if: ${{ inputs.docker_old}}
    runs-on: ubuntu-latest
    name: GHCR Release Old
    permissions:
      contents: read
      packages: write
      # This is used to complete the identity challenge
      # with sigstore/fulcio when running outside of PRs.
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{inputs.version}}
      - run: git checkout ${{needs.get_commit.outputs.long}}
      - name: get tag
        run: echo release=$(git describe --tags `git rev-list --tags --max-count=1`) >> $GITHUB_ENV
      - name: Setup Docker buildx
        uses: docker/setup-buildx-action@v2
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2
      #Install the cosign tool except on PR
      #https://github.com/sigstore/cosign-installer
      - name: Install cosign
        uses: sigstore/cosign-installer@main #v2.6.0
        with:
          cosign-release: v1.13.1
      #Login against a Docker registry except on PR
      #https://github.com/docker/login-action

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      - name: login to ghcr
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN}}
          # Extract metadata (tags, labels) for Docker
      - name: push image to ghcr
        id: build-and-push2
        uses: docker/build-push-action@v4
        with:
          context: .
          tags: |
            ghcr.io/datawhores/of-scraper:${{ inputs.version }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          push: true
