name: package builder release
permissions: read-all
on:
  workflow_dispatch:
    inputs:
      version:
        description: 'The exact git tag to build (e.g., v8.4.1)'
        required: true
      files:
        description: 'Build binary files? (true/false)'
        required: true
        type: boolean
      pip:
        description: 'Publish to PyPI? (true/false)'
        required: true
        type: boolean
      docker:
        description: 'Publish to Docker Hub & GHCR (latest)? (true/false)'
        required: true
        type: boolean
      docker_old:
        description: 'Publish to Docker Hub & GHCR (version only)? (true/false)'
        required: true
        type: boolean
jobs:
  get_commit:
    runs-on: ubuntu-latest
    outputs:
      long: ${{ steps.commit.outputs.long }}
    steps:
      - name: Checkout code at specified version
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.version }}
      - name: Get commit hash
        id: commit
        run: echo "long=$(git rev-parse HEAD)" >> "$GITHUB_OUTPUT"

  build_binaries:
    if: ${{ inputs.files }}
    name: Build on ${{ matrix.os }}
    needs: [get_commit]
    runs-on: ${{ matrix.os }}

    defaults:
      run:
        shell: ${{ matrix.shell }}

    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        include:
          - os: ubuntu-latest
            artifact_suffix: linux
            shell: bash
          - os: windows-latest
            artifact_suffix: windows
            shell: pwsh
          - os: macos-latest
            artifact_suffix: macos
            shell: bash

    steps:
      # ... steps to checkout, setup python, install dependencies, and build ...
      - name: Checkout Full Git History
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          ref: ${{ inputs.version }}
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12.0'
      - name: Install uv
        uses: astral-sh/setup-uv@v4
      - name: Get version from workflow input
        id: get_version
        run: |
          INPUT_VERSION="${{ inputs.version }}"
          SELECTED_TAG=${INPUT_VERSION#v}
          SANITIZED_TAG="${SELECTED_TAG//./_}"
          echo "SETUPTOOLS_SCM_PRETEND_VERSION=$SELECTED_TAG" >> $GITHUB_ENV
          echo "HATCH_VCS_PRETEND_VERSION=$SELECTED_TAG" >> $GITHUB_ENV
          echo "selected_tag=$SELECTED_TAG" >> "$GITHUB_OUTPUT"
          echo "sanitized_tag=$SANITIZED_TAG" >> "$GITHUB_OUTPUT"
        shell: bash
      - name: Install venv and dependencies
        run: |
          uv venv
          if [ "${{ runner.os }}" == "Windows" ]; then
            . .venv/Scripts/activate
          else
            source .venv/bin/activate
          fi
          uv pip install --upgrade hatch-vcs setuptools-scm
          uv sync --verbose
        shell: bash
      - name: Install PyInstaller
        run: uv pip install pyinstaller==6.14.1
      - name: Set UTF-8 environment (Windows)
        if: runner.os == 'Windows'
        run: |
          echo "PYTHONUTF8=1" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "PYTHONLEGACYWINDOWSSTDIO=utf8" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        shell: pwsh
      - name: Build Executable (File)
        run: |
          if [ "${{ runner.os }}" == "Windows" ]; then
              VENV_ACTIVATE=".venv/Scripts/activate"
              PYINSTALLER_OPTS="--python-option=utf8"
              EXE_EXT=".exe"
          else
              VENV_ACTIVATE=".venv/bin/activate"
              PYINSTALLER_OPTS="--clean --log DEBUG"
              EXE_EXT=""
          fi
          source $VENV_ACTIVATE
          pyinstaller --onefile \
            --name "ofscraper_${{ matrix.artifact_suffix }}_${{ steps.get_version.outputs.sanitized_tag }}$EXE_EXT" \
            $PYINSTALLER_OPTS \
            "ofscraper/__main__.py"
        shell: bash
      - name: Build Executable (Dir)
        run: |
          if [ "${{ runner.os }}" == "Windows" ]; then
              VENV_ACTIVATE=".venv/Scripts/activate"
              PYINSTALLER_OPTS="--python-option=utf8"
          else
              VENV_ACTIVATE=".venv/bin/activate"
              PYINSTALLER_OPTS="--clean --log DEBUG"
          fi
          source $VENV_ACTIVATE
          pyinstaller\
            --name "ofscraper_${{ matrix.artifact_suffix }}_dir" \
            $PYINSTALLER_OPTS \
            "ofscraper/__main__.py"
        shell: bash
      - name: Zip Directory (Unix)
        if: runner.os != 'Windows'
        run: zip -r "dist/ofscraper_${{ matrix.artifact_suffix }}_${{ steps.get_version.outputs.sanitized_tag }}.zip" "dist/ofscraper_${{ matrix.artifact_suffix }}_dir"
        shell: bash
      - name: Zip Directory (Windows)
        if: runner.os == 'Windows'
        run: Compress-Archive -Path dist/ofscraper_${{ matrix.artifact_suffix }}_dir -DestinationPath dist/ofscraper_${{ matrix.artifact_suffix }}_${{ steps.get_version.outputs.sanitized_tag }}.zip -Force
        shell: pwsh

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          # FIX 1: Make artifact name unique for each job in the matrix
          name: build-artifacts-${{ matrix.os }}
          path: |
            dist/ofscraper_${{ matrix.artifact_suffix }}_${{ steps.get_version.outputs.sanitized_tag }}
            dist/ofscraper_${{ matrix.artifact_suffix }}_${{ steps.get_version.outputs.sanitized_tag }}.exe
            dist/ofscraper_${{ matrix.artifact_suffix }}_${{ steps.get_version.outputs.sanitized_tag }}.zip
          if-no-files-found: ignore
          
  publish_release:
    name: Publish GitHub Release
    if: ${{ inputs.files }}
    needs: [build_binaries, get_commit]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          # FIX 2: Download all artifacts into a parent directory.
          # This creates subdirectories like artifacts/build-artifacts-windows/
          path: artifacts/

      - name: List downloaded files for debugging
        run: ls -R artifacts

      - name: Create or Update Release
        uses: ncipollo/release-action@v1
        with:
          # FIX 3: Use a glob that searches inside the subdirectories
          artifacts: artifacts/*/*
          tag: ${{ inputs.version }}
          name: "Release ${{ inputs.version }}"
          body: "Release build for version ${{ inputs.version }}, created from commit hash `${{ needs.get_commit.outputs.long }}`."
          allowUpdates: true
          
  # ... other jobs (pypi, docker, etc.) remain unchanged ...
  pypi:
    needs: [get_commit]
    if: ${{ inputs.pip }}
    runs-on: ubuntu-latest
    name: create pypi
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          ref: ${{ inputs.version }}
      - run: git checkout ${{ needs.get_commit.outputs.long }}
      - name: Set up Python 3.11.5
        uses: actions/setup-python@v4
        with:
          python-version: 3.11.5
      - name: üêç Install dependencies
        run: |
          pip install poetry-dynamic-versioning
          pip install dunamai
      - name: Install Poetry
        uses: snok/install-poetry@v1
      - name: Build
        run: |
          poetry version $(dunamai from git --format "{base}" --pattern="(?P<base>\d+\.\d+(\.((\d+\.\w+)|\w+)|))")
          poetry build
      - name: Push to pypi
        env:
          PYPI_TOKEN: ${{ secrets.pypi }}
        run: |
          poetry config pypi-token.pypi $PYPI_TOKEN
          poetry publish
          
  docker:
    needs: [get_commit]
    if: ${{ inputs.docker }}
    runs-on: ubuntu-latest
    name: DockerHub Release
    permissions:
      contents: read
      packages: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.version }}
      - run: git checkout ${{ needs.get_commit.outputs.long }}
      - name: get tag
        run: echo release=$(git describe --tags `git rev-list --tags --max-count=1`) >> $GITHUB_ENV
      - name: Setup Docker buildx
        uses: docker/setup-buildx-action@v2
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2
      - name: Install cosign
        uses: sigstore/cosign-installer@main
        with:
          cosign-release: v1.13.1
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - name: push image to Docker Hub
        id: build-and-push
        uses: docker/build-push-action@v4
        with:
          context: .
          tags: |
            datawhores/of-scraper:${{ inputs.version }}
            datawhores/of-scraper:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          push: true
      - name: cosign-installer
        uses: sigstore/cosign-installer@v3.0.5
      - name: Write signing key to disk
        run: echo "$KEY" > cosign.key
        shell: bash
        env:
          KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
      - name: Sign the published Docker image
        env:
          COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
          COSIGN_EXPERIMENTAL: "true"
        run: echo "datawhores/of-scraper:${{ env.release }}" | xargs -I {} cosign sign --yes --key cosign.key {}@${{ steps.build-and-push.outputs.digest }}

  github_docker:
    needs: [get_commit]
    if: ${{ inputs.docker }}
    runs-on: ubuntu-latest
    name: Docker GHCR Release
    permissions:
      contents: read
      packages: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.version }}
      - run: git checkout ${{ needs.get_commit.outputs.long }}
      - name: get tag
        run: echo release=$(git describe --tags `git rev-list --tags --max-count=1`) >> $GITHUB_ENV
      - name: Setup Docker buildx
        uses: docker/setup-buildx-action@v2
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2
      - name: Install cosign
        uses: sigstore/cosign-installer@main
        with:
          cosign-release: v1.13.1
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      - name: login to ghcr
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN}}
      - name: push image to ghcr
        id: build-and-push2
        uses: docker/build-push-action@v4
        with:
          context: .
          tags: |
            ghcr.io/datawhores/of-scraper:${{ inputs.version }}
            ghcr.io/datawhores/of-scraper:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          push: true

  docker_old:
    needs: [get_commit]
    if: ${{ inputs.docker_old }}
    runs-on: ubuntu-latest
    name: DockerHub Release Old
    permissions:
      contents: read
      packages: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.version }}
      - run: git checkout ${{ needs.get_commit.outputs.long }}
      - name: get tag
        run: echo release=$(git describe --tags `git rev-list --tags --max-count=1`) >> $GITHUB_ENV
      - name: Setup Docker buildx
        uses: docker/setup-buildx-action@v2
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2
      - name: Install cosign
        uses: sigstore/cosign-installer@main
        with:
          cosign-release: v1.13.1
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - name: push image to Docker Hub
        id: build-and-push
        uses: docker/build-push-action@v4
        with:
          context: .
          tags: |
            datawhores/of-scraper:${{ inputs.version }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          push: true
      - name: cosign-installer
        uses: sigstore/cosign-installer@v3.0.5
      - name: Write signing key to disk
        run: echo "$KEY" > cosign.key
        shell: bash
        env:
          KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
      - name: Sign the published Docker image
        env:
          COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
          COSIGN_EXPERIMENTAL: "true"
        run: echo "datawhores/of-scraper:${{ env.release }}" | xargs -I {} cosign sign --yes --key cosign.key {}@${{ steps.build-and-push.outputs.digest }}

  docker_old_github:
    needs: [get_commit]
    if: ${{ inputs.docker_old }}
    runs-on: ubuntu-latest
    name: GHCR Release Old
    permissions:
      contents: read
      packages: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.version }}
      - run: git checkout ${{ needs.get_commit.outputs.long }}
      - name: get tag
        run: echo release=$(git describe --tags `git rev-list --tags --max-count=1`) >> $GITHUB_ENV
      - name: Setup Docker buildx
        uses: docker/setup-buildx-action@v2
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2
      - name: Install cosign
        uses: sigstore/cosign-installer@main
        with:
          cosign-release: v1.13.1
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      - name: login to ghcr
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN}}
      - name: push image to ghcr
        id: build-and-push2
        uses: docker/build-push-action@v4
        with:
          context: .
          tags: |
            ghcr.io/datawhores/of-scraper:${{ inputs.version }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          push: true